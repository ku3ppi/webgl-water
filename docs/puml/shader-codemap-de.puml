@startuml Shader Code Map
!theme plain

title WebGL Water - Shader Variablen und Konstanten Code-Karte

package "Water Vertex Shader" {

  class WaterVertexShader {
    **Attribute:**
    + attribute position: vec3

    **Uniforms:**
    + uniform perspective: mat4
    + uniform model: mat4
    + uniform view: mat4
    + uniform cameraPos: vec3

    **Varyings (Output):**
    + varying clipSpace: vec4
    + varying textureCoords: vec2
    + varying fromFragmentToCamera: vec3

    **Konstanten:**
    + const tiling: float = 4.0

    **Berechnungen:**
    worldPosition = model * vec4(position, 1.0)
    clipSpace = perspective * view * worldPosition
    textureCoords = (position.xz + 0.5) * tiling
    fromFragmentToCamera = cameraPos - worldPosition.xyz
  }

}

package "Water Fragment Shader" {

  class WaterFragmentShader {
    **Textur Samplers:**
    + uniform refractionTexture: sampler2D
    + uniform reflectionTexture: sampler2D
    + uniform dudvTexture: sampler2D
    + uniform normalMap: sampler2D
    + uniform waterDepthTexture: sampler2D

    **Animation & Eigenschaften:**
    + uniform dudvOffset: float
    + uniform waterReflectivity: float
    + uniform fresnelStrength: float

    **Varyings (Input):**
    + varying clipSpace: vec4
    + varying textureCoords: vec2
    + varying fromFragmentToCamera: vec3

    **Konstanten:**
    + const waterDistortionStrength: float = 0.03
    + const shineDamper: float = 20.0

    **Licht Konstanten:**
    + vec3 sunlightColor = vec3(1.0, 1.0, 1.0)
    + vec3 sunlightDir = normalize(vec3(-1.0, -1.0, 0.5))

    **Wasser Farben:**
    + vec4 shallowWaterColor = vec4(0.0, 0.1, 0.3, 1.0)
    + vec4 deepWaterColor = vec4(0.0, 0.1, 0.2, 1.0)

    **Funktionen:**
    + getNormal(textureCoords): vec3
  }

  class WaterCalculations {
    **NDC Berechnung:**
    ndc = (clipSpace.xy / clipSpace.w) / 2.0 + 0.5

    **Textur Koordinaten:**
    refractTexCoords = vec2(ndc.x, ndc.y)
    reflectTexCoords = vec2(ndc.x, -ndc.y)

    **Tiefen Berechnung:**
    near = 0.1, far = 50.0
    cameraToFirstThingUnderWater = 2.0 * near * far / ...
    angledWaterDepth = underwater - waterDistance

    **Verzerrung:**
    distortedTexCoords = dudvTexture + dudvOffset
    totalDistortion = (dudvTexture * 2.0 - 1.0) * strength

    **Fresnel Effekt:**
    refractiveFactor = dot(toCamera, normal)
    refractiveFactor = pow(refractiveFactor, fresnelStrength)
  }

}

package "Mesh Vertex Shader" {

  class MeshVertexShader {
    **Attribute:**
    + attribute position: vec3
    + attribute normal: vec3
    + attribute uvs: vec2

    **Uniforms:**
    + uniform perspective: mat4
    + uniform view: mat4
    + uniform model: mat4
    + uniform clipPlane: vec4

    **Varyings (Output):**
    + varying vUvs: vec2
    + varying vNormal: vec3
    + varying vWorldPos: vec3

    **Clipping:**
    gl_ClipDistance[0] = dot(worldPos, clipPlane)
  }

}

package "Mesh Fragment Shader" {

  class MeshFragmentShader {
    **Uniforms:**
    + uniform tex: sampler2D

    **Varyings (Input):**
    + varying vUvs: vec2
    + varying vNormal: vec3

    **Output:**
    gl_FragColor = texture2D(tex, vUvs)
  }

}

package "Textured Quad Shader" {

  class QuadVertexShader {
    **Attribute:**
    + attribute position: vec2

    **Varyings:**
    + varying textureCoords: vec2

    **Berechnung:**
    textureCoords = position * 0.5 + 0.5
    gl_Position = vec4(position, 0.0, 1.0)
  }

  class QuadFragmentShader {
    **Uniforms:**
    + uniform texture: sampler2D

    **Varyings:**
    + varying textureCoords: vec2

    **Output:**
    gl_FragColor = texture2D(texture, textureCoords)
  }

}

package "Shader Pipeline Datenfluss" {

  class RenderingPasses {
    **Refraktion Pass:**
    clipPlane = vec4(0, -1, 0, 0)
    → render terrain below water
    → output to refractionTexture

    **Reflektion Pass:**
    clipPlane = vec4(0, 1, 0, 0)
    → flip view matrix
    → render terrain above water
    → output to reflectionTexture

    **Wasser Pass:**
    → bind refractionTexture (TEXTURE0)
    → bind reflectionTexture (TEXTURE1)
    → bind dudvTexture (TEXTURE2)
    → bind normalMap (TEXTURE3)
    → dudvOffset = (time / 1000.0) * waveSpeed
    → render water plane
  }

}

WaterVertexShader --> WaterFragmentShader : clipSpace, textureCoords, fromFragmentToCamera
WaterFragmentShader --> WaterCalculations : verwendet
MeshVertexShader --> MeshFragmentShader : vUvs, vNormal
QuadVertexShader --> QuadFragmentShader : textureCoords

note right of WaterFragmentShader
**Textur Binding:**
TEXTURE0 → refractionTexture
TEXTURE1 → reflectionTexture
TEXTURE2 → dudvTexture
TEXTURE3 → normalMap
TEXTURE4 → waterDepthTexture
end note

note bottom of WaterCalculations
**Fresnel Formel:**
Je steiler der Blickwinkel, desto mehr Reflektion
Je flacher der Blickwinkel, desto mehr Refraktion
fresnelStrength = 2.0 für realistische Wasser
end note

note left of RenderingPasses
**Clip Planes:**
Negative Y: Alles unter Wasser (Refraktion)
Positive Y: Alles über Wasser (Reflektion)
end note

@enduml
